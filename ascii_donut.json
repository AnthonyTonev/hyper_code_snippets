{
        "title": "ascii_donut",
        "description": "visit https://www.a1k0n.net/2011/07/20/donut-math.html",
        "files":["index.html","main.js","README.txt"],
        "code":"{\"0\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <style>\\n  body{\\n  background-color:black;\\n  }\\n  </style>\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n    <title>Document</title>\\n</head>\\n<body>\\n  <script type=\\\"module\\\" src=\\\"main.js\\\"></script>\\n</body>\\n</html>\",\"1\":\"const donut = function() {\\n  const pretag = document.createElement(\\\"pre\\\");\\n  pretag.style = \\\"background:black;color:#ddffff;margin-top:25%\\\";\\n  document.body.appendChild(pretag);\\n\\n  let tmr1 = undefined, tmr2 = undefined;\\n  let A=1, B=1;\\n\\n  const asciiframe=function() {\\n    const b=[];\\n    const z=[];\\n    A += 0.07;\\n    B += 0.03;\\n    const cA=Math.cos(A), sA=Math.sin(A),\\n        cB=Math.cos(B), sB=Math.sin(B);\\n    for(let k=0;k<1760;k++) {\\n      b[k]=k%80 == 79 ? \\\"\\\\n\\\" : \\\" \\\";\\n      z[k]=0;\\n    }\\n    for(let j=0;j<6.28;j+=0.07) { // j <=> theta\\n      const ct=Math.cos(j),st=Math.sin(j);\\n      for(let i=0;i<6.28;i+=0.02) {   // i <=> phi\\n        const sp=Math.sin(i),cp=Math.cos(i),\\n            h=ct+2, // R1 + R2*cos(theta)\\n            D=1/(sp*h*sA+st*cA+5), // this is 1/z\\n            t=sp*h*cA-st*sA; // this is a clever factoring of some of the terms in x' and y'\\n\\n        const x=0|(40+30*D*(cp*h*cB-t*sB)),\\n            y=0|(12+15*D*(cp*h*sB+t*cB)),\\n            o=x+80*y,\\n            N=0|(8*((st*sA-sp*ct*cA)*cB-sp*ct*sA-st*cA-cp*ct*sB));\\n        if(y<22 && y>=0 && x>=0 && x<79 && D>z[o])\\n        {\\n          z[o]=D;\\n          b[o]=\\\".,-~:;=!*#$@\\\"[N>0?N:0];\\n        }\\n      }\\n    }\\n    pretag.innerHTML = b.join(\\\"\\\");\\n  };\\n\\n\\n\\nsetInterval(asciiframe, 35);\\n  asciiframe();\\n}\\ndonut();\\n\\n\",\"2\":\"There has been a sudden resurgence of interest in my “donut” code from 2006, and I’ve had a couple requests to explain this one. It’s been five years now, so it’s not exactly fresh in my memory, so I will reconstruct it from scratch, in great detail, and hopefully get approximately the same result.\\n\\nThis is the code:\\n\\n             k;double sin()\\n         ,cos();main(){float A=\\n       0,B=0,i,j,z[1760];char b[\\n     1760];printf(\\\"\\\\x1b[2J\\\");for(;;\\n  ){memset(b,32,1760);memset(z,0,7040)\\n  ;for(j=0;6.28>j;j+=0.07)for(i=0;6.28\\n >i;i+=0.02){float c=sin(i),d=cos(j),e=\\n sin(A),f=sin(j),g=cos(A),h=d+2,D=1/(c*\\n h*e+f*g+5),l=cos      (i),m=cos(B),n=s\\\\\\nin(B),t=c*h*g-f*        e;int x=40+30*D*\\n(l*h*m-t*n),y=            12+15*D*(l*h*n\\n+t*m),o=x+80*y,          N=8*((f*e-c*d*g\\n )*m-c*d*e-f*g-l        *d*n);if(22>y&&\\n y>0&&x>0&&80>x&&D>z[o]){z[o]=D;;;b[o]=\\n \\\".,-~:;=!*#$@\\\"[N>0?N:0];}}/*#****!!-*/\\n  printf(\\\"\\\\x1b[H\\\");for(k=0;1761>k;k++)\\n   putchar(k%80?b[k]:10);A+=0.04;B+=\\n     0.02;}}/*****####*******!!=;:~\\n       ~::==!!!**********!!!==::-\\n         .,~~;;;========;;;:~-.\\n             ..,--------,*/\\n\\n\\n\\n                                   @@@@@@@@                                    \\n                               ####$$$$$$$$@@@$$                               \\n                             *******#####$$$$$$$$$$                            \\n                            =====!!!!***#####$$$$$$$#                          \\n                           :;;;;;;==!!!****########$###                        \\n                           ::~~::;;;=!!=!!*****#########                       \\n                           --,,-~~~:;;;===!******#*#####**                     \\n                           ,.....,-~~:;:====!!*!***********                    \\n                           .........--~::;;===!!!*!********!                   \\n                           ..........,--~:;;;;==!!!!!*****!!                   \\n                            ...........,-~~::;;===!=!!!!!!!!=                  \\n                             ......,,-..,,-~::;;;====!=!!!!!=                  \\n                             .,-~~~;;##..,,-~~::;;;==========;                 \\n                              .-~;=*#$$@...,-~~:::;;;;;======;                 \\n                                -;!!*#$$#...,--~~:::;;;;;;;;;:                 \\n                                 -;=!**!=~...,---~:::::;;;;;:                  \\n                                  ,:=:;;:-...,,,--~~~:::::::~                  \\n                                    -:;:~-.....,,--~~~~~~~~~                   \\n                                      ,--,.....,,,---------                    \\n                                        .........,,,,,,,,,                     \\n                                           .............                       \\n                                                                               \\nAt its core, it’s a framebuffer and a Z-buffer into which I render pixels. Since it’s just rendering relatively low-resolution ASCII art, I massively cheat. All it does is plot pixels along the surface of the torus at fixed-angle increments, and does it densely enough that the final result looks solid. The “pixels” it plots are ASCII characters corresponding to the illumination value of the surface at each point: .,-~:;=!*#$@ from dimmest to brightest. No raytracing required.\\n\\nSo how do we do that? Well, let’s start with the basic math behind 3D perspective rendering. The following diagram is a side view of a person sitting in front of a screen, viewing a 3D object behind it.\\n\\n\\nTo render a 3D object onto a 2D screen, we project each point (x,y,z) in 3D-space onto a plane located z’ units away from the viewer, so that the corresponding 2D position is (x’,y’). Since we’re looking from the side, we can only see the y and z axes, but the math works the same for the x axis (just pretend this is a top view instead). This projection is really easy to obtain: notice that the origin, the y-axis, and point (x,y,z) form a right triangle, and a similar right triangle is formed with (x’,y’,z’). Thus the relative proportions are maintained:\\n\\ny′z′y′=yz=yz′z.\\nSo to project a 3D coordinate to 2D, we scale a coordinate by the screen distance z’. Since z’ is a fixed constant, and not functionally a coordinate, let’s rename it to K1, so our projection equation becomes (x′,y′)=(K1xz,K1yz). We can choose K1 arbitrarily based on the field of view we want to show in our 2D window. For example, if we have a 100x100 window of pixels, then the view is centered at (50,50); and if we want to see an object which is 10 units wide in our 3D space, set back 5 units from the viewer, then K1 should be chosen so that the projection of the point x=10, z=5 is still on the screen with x’ < 50: 10K1/5 < 50, or K1 < 25.\\n\\nWhen we’re plotting a bunch of points, we might end up plotting different points at the same (x’,y’) location but at different depths, so we maintain a z-buffer which stores the z coordinate of everything we draw. If we need to plot a location, we first check to see whether we’re plotting in front of what’s there already. It also helps to compute z-1 =1z and use that when depth buffering because:\\n\\nz-1 = 0 corresponds to infinite depth, so we can pre-initialize our z-buffer to 0 and have the background be infinitely far away\\nwe can re-use z-1 when computing x’ and y’: Dividing once and multiplying by z-1 twice is cheaper than dividing by z twice.\\nNow, how do we draw a donut, AKA torus? Well, a torus is a solid of revolution, so one way to do it is to draw a 2D circle around some point in 3D space, and then rotate it around the central axis of the torus. Here is a cross-section through the center of a torus:\\n\\n\\nSo we have a circle of radius R1 centered at point (R2,0,0), drawn on the xy-plane. We can draw this by sweeping an angle — let’s call it θ — from 0 to 2π:\\n\\n(x,y,z)=(R2,0,0)+(R1cosθ,R1sinθ,0)\\nNow we take that circle and rotate it around the y-axis by another angle — let’s call it φ. To rotate an arbitrary 3D point around one of the cardinal axes, the standard technique is to multiply by a rotation matrix. So if we take the previous points and rotate about the y-axis we get:\\n\\n(R2+R1cosθ,R1sinθ,0)⋅⎛⎝⎜cosϕ0−sinϕ010sinϕ0cosϕ⎞⎠⎟\\n=((R2+R1cosθ)cosϕ,R1sinθ,−(R2+R1cosθ)sinϕ)\\nBut wait: we also want the whole donut to spin around on at least two more axes for the animation. They were called A and B in the original code: it was a rotation about the x-axis by A and a rotation about the z-axis by B. This is a bit hairier, so I’m not even going write the result yet, but it’s a bunch of matrix multiplies.\\n\\n(R2+R1cosθ,R1sinθ,0)⋅⎛⎝⎜cosϕ0−sinϕ010sinϕ0cosϕ⎞⎠⎟⋅⎛⎝⎜1000cosA−sinA0sinAcosA⎞⎠⎟⋅⎛⎝⎜cosB−sinB0sinBcosB0001⎞⎠⎟\\nChurning through the above gets us an (x,y,z) point on the surface of our torus, rotated around two axes, centered at the origin. To actually get screen coordinates, we need to:\\n\\nMove the torus somewhere in front of the viewer (the viewer is at the origin) — so we just add some constant to z to move it backward.\\nProject from 3D onto our 2D screen.\\nSo we have another constant to pick, call it K2, for the distance of the donut from the viewer, and our projection now looks like:\\n\\n(x′,y′)=(K1xK2+z,K1yK2+z)\\nK1 and K2 can be tweaked together to change the field of view and flatten or exaggerate the depth of the object.\\n\\nNow, we could implement a 3x3 matrix multiplication routine in our code and implement the above in a straightforward way. But if our goal is to shrink the code as much as possible, then every 0 in the matrices above is an opportunity for simplification. So let’s multiply it out. Churning through a bunch of algebra (thanks Mathematica!), the full result is:\\n\\n⎛⎝⎜xyz⎞⎠⎟=⎛⎝⎜(R2+R1cosθ)(cosBcosϕ+sinAsinBsinϕ)−R1cosAsinBsinθ(R2+R1cosθ)(cosϕsinB−cosBsinAsinϕ)+R1cosAcosBsinθcosA(R2+R1cosθ)sinϕ+R1sinAsinθ⎞⎠⎟\\nWell, that looks pretty hideous, but we we can precompute some common subexpressions (e.g. all the sines and cosines, and R2+R1cosθ) and reuse them in the code. In fact I came up with a completely different factoring in the original code but that’s left as an exercise for the reader. (The original code also swaps the sines and cosines of A, effectively rotating by 90 degrees, so I guess my initial derivation was a bit different but that’s OK.)\\n\\nNow we know where to put the pixel, but we still haven’t even considered which shade to plot. To calculate illumination, we need to know the surface normal — the direction perpendicular to the surface at each point. If we have that, then we can take the dot product of the surface normal with the light direction, which we can choose arbitrarily. That gives us the cosine of the angle between the light direction and the surface direction: If the dot product is >0, the surface is facing the light and if it’s <0, it faces away from the light. The higher the value, the more light falls on the surface.\\n\\nThe derivation of the surface normal direction turns out to be pretty much the same as our derivation of the point in space. We start with a point on a circle, rotate it around the torus’s central axis, and then make two more rotations. The surface normal of the point on the circle is fairly obvious: it’s the same as the point on a unit (radius=1) circle centered at the origin.\\n\\nSo our surface normal (Nx, Ny, Nz) is derived the same as above, except the point we start with is just (cos θ, sin θ, 0). Then we apply the same rotations:\\n\\n(Nx,Ny,Nz)=(cosθ,sinθ,0)⋅⎛⎝⎜cosϕ0−sinϕ010sinϕ0cosϕ⎞⎠⎟⋅⎛⎝⎜1000cosA−sinA0sinAcosA⎞⎠⎟⋅⎛⎝⎜cosB−sinB0sinBcosB0001⎞⎠⎟\\nSo which lighting direction should we choose? How about we light up surfaces facing behind and above the viewer: (0,1,−1). Technically this should be a normalized unit vector, and this vector has a magnitude of √2. That’s okay – we will compensate later. Therefore we compute the above (x,y,z), throw away the x and get our luminance L = y-z.\\n\\nL=(Nx,Ny,Nz)⋅(0,1,−1)=cosϕcosθsinB−cosAcosθsinϕ−sinAsinθ+cosB(cosAsinθ−cosθsinAsinϕ)\\nAgain, not too pretty, but not terrible once we’ve precomputed all the sines and cosines.\\n\\nSo now all that’s left to do is to pick some values for R1, R2, K1, and K2. In the original donut code I chose R1=1 and R2=2, so it has the same geometry as my cross-section diagram above. K1 controls the scale, which depends on our pixel resolution and is in fact different for x and y in the ASCII animation. K2, the distance from the viewer to the donut, was chosen to be 5.\\n\\nI’ve taken the above equations and written a quick and dirty canvas implementation here, just plotting the pixels and the lighting values from the equations above. The result is not exactly the same as the original as some of my rotations are in opposite directions or off by 90 degrees, but it is qualitatively doing the same thing.\\n\\nHere it is: toggle animation\\n\\nIt’s slightly mind-bending because you can see right through the torus, but the math does work! Convert that to an ASCII rendering with z-buffering, and you’ve got yourself a clever little program.\\n\\n\\n\\nMy little donut.c has been making the rounds again, after being featured in a couple YouTube videos (e.g., Lex Fridman and Joma Tech). If I had known how much attention this code would get over the years, I would have spent more time on it.\\n\\nOne thing that’s always been sort of unfortunate is the heavy use of sin and cos – both because it necessitates linking the math library (-lm), but also because it makes it much more CPU-intensive than it really needs to be. This is especially apparent if you try to port it to an older CPU or an embedded device.\\n\\nSo, here’s a revised version with no use of sin, cos, and no need for linking the math library (though this version still does use float types).\\n\\n             i,j,k,x,y,o,N;\\n         main(){float z[1760],a\\n      #define R(t,x,y) f=x;x-=t*y\\\\\\n   ;y+=t*f;f=(3-x*x-y*y)/2;x*=f;y*=f;\\n   =0,e=1,c=1,d=0,f,g,h,G,H,A,t,D;char\\n b[1760];for(;;){memset(b,32,1760);g=0,\\nh=1;memset(z,0,7040);for(j=0;j<90;j++){\\nG=0,H=1;for(i=0;i<314;i++){A=h+2,D=1/(G*\\nA*a+g*e+5);t=G*A        *e-g*a;x=40+30*D\\n*(H*A*d-t*c);y=          12+15*D*(H*A*c+\\nt*d);o=x+80*y;N          =8*((g*a-G*h*e)\\n*d-G*h*a-g*e-H*h        *c);if(22>y&&y>\\n 0&&x>0&&80>x&&D>z[o]){z[o]=D;b[o]=(N>0\\n  ?N:0)[\\\".,-~:;=!*#$@\\\"];}R(.02,H,G);}R(\\n  .07,h,g);}for(k=0;1761>k;k++)putchar\\n   (k%80?b[k]:10);R(.04,e,a);R(.02,d,\\n     c);usleep(15000);printf('\\\\n'+(\\n        \\\" donut.c! \\\\x1b[23A\\\"));}}\\n          /*no math lib needed\\n             .@a1k0n 2021.*/\\nIt’s a little misshapen and still has comments at the bottom. I used the first frame of its output as a template and there’s slightly less code than filled pixels – oh well. Output is pretty much the same as before:\\n\\ntoggle animation\\n\\n                                                                               \\n                                                                               \\n                                  @@@$$$$$$@@@@                                \\n                              $$$$#############$$$$                            \\n                           #####***!*!!!!!!*****###$$#                         \\n                         ####**!!!!!!!====!!!!!!***#####                       \\n                        ##****!!!==;;::::::;;==!!!!***##*                      \\n                       ****!!!==;;:~-,,,,,--~::;==!!******                     \\n                      ****!!!==::~-.........,-~:;==!!*****!                    \\n                     =!**!!!==;:-,............,~:;==!!****!                    \\n                     !!**!!!==;~-,..        ..,-:;==!!****!=                   \\n                     =!!*!!!!=;:~,.          .,~;==!!!!*!!!=                   \\n                     ;!!!***!!!!=;~          ~:;;==!!!!!!!!;                   \\n                     ;=!!********!!=        ;=!!*!!***!!!!=;                   \\n                     :=!!!***#########**!**##*********!!!=;~                   \\n                      :=!!****###$$$@@@@$$$$$$####***!!!=;:                    \\n                       :;!!****###$$$@@@@@$$$$###**!!!!=;~                     \\n                        ~;=!!!***####$$$$$$####**!!!!=;:~                      \\n                         -~;=!!*******####******!!!=;:~,                       \\n                           -~:==!!!*!****!**!!!!==;:~.                         \\n                              ,~~:;;;=======;;;:~-.                            \\n                                 ..,--------,,.                                \\nDefining a rotation\\nSo, how do we get sines and cosines without using sin and cos? Well, the code doesn’t really need sine and cosine per se; what it actually does is rotate a point around the origin in two nested loops, and also rotate two angles just for the animation. If you’ll recall from the other article, the inner loop is just plotting dots in a circle, which goes around another, larger circle. In each loop, the sine/cosine terms are just moving by a small, fixed angle.\\n\\nSo we don’t need to track the angle at all, we only need to start at cos=1, sin=0 and rotate a circle around the origin to generate all the sines and cosines we need. We just have to repeatedly apply a fixed rotation matrix:\\n\\n[c′s′]=[cosθsinθ−sinθcosθ][cs]\\nSo for example, if we were to use an angle of .02 radians in our inner loop, it would look something like:\\n\\nfloat c=1, s=0;  // c for cos, s for sin\\nfor (int i = 0; i < 314; i++) {  // 314 * .02 ~= 2π\\n  // (use c, s in code)\\n  float newc = 0.9998*c - 0.019998666*s;\\n  s = 0.019998666*c + 0.9998*s;\\n  c = newc;\\n}\\nRenormalizing\\nThat works, but there’s a problem: no matter how precisely we define our constants, after repeated iteration of this procedure, the magnitude of our (c,s) vector will exponentially grow or shrink over time. If we only need to make one pass around the loop, maybe we can get away with that, but if we have to make several (for the rotating animation, we do), we need to fix that.\\n\\nsine and cosine magnitude creep\\nan exaggerated illustration of what happens when repeatedly doing low-precision rotations\\n\\nThe simplest way to do that would be to multiply c and s by 1/c2+s2−−−−−−√, but then we’re back to using the math library again. Instead, we can take advantage of the fact that our magnitude starts out very close to 1, and we’re going to be iterating this procedure: we can do a Newton step after each rotation, and that will be enough to keep the magnitude “close enough” to 1 over time.\\n\\nOur goal is to find the reciprocal square root (sound familiar?) of a=c2+s2, our (c,s) vector magnitude. Say we define a function f(x)=1x2−a. The function is 0 when x=1a√. We can start with an initial guess of 1 for x, perform a Newton iteration to obtain x’, which will be “closer to” 1a√, the correct value to scale c and s by so that their magnitude c2+s2 is “close to” 1 again.\\n\\nA Newton step is defined as x′=x−f(x)f′(x). I used SymPy to do the derivative and simplification and came up with x′=x(3−ax2)2. Since we’re only doing one step, we can plug in our initial guess of 1 for x and back-substitute c2+s2 for a to finally get our adjustment: x′=(3−c2−s2)/2.\\n\\nFurther simplifying the rotation\\nBut now that we don’t have to worry so much about the magnitude of our result (within limits), we can take another shortcut (I got this idea studying old CORDIC algorithms). If we divide out the cosines from our original rotation matrix, we get\\n\\n[c′s′]=1cosθ[1tanθ−tanθ1][cs]\\nusing the trig identity tanθ=sinθcosθ. Since we’re only dealing with small angles, the leading 1cosθ term is close enough to 1 that we can ignore it and have our Newton step take care of it.\\n\\nAnd now we can finally understand how the rotation is done in the code. Towards the top of the donut code is this #define, which I’ve reindented:\\n\\n#define R(t,x,y) \\\\ \\n  f = x; \\\\\\n  x -= t*y; \\\\\\n  y += t*f; \\\\\\n  f = (3-x*x-y*y)/2; \\\\\\n  x *= f; \\\\\\n  y *= f;\\nThis does an in-place rotation of a unit vector x, y where t is tanθ. f is a temporary variable; the first three lines do the “matrix multiplication” on x, y. f is then re-used to get the magnitude adjustment, and then finally x and y are multiplied by f which moves them back onto the unit circle.\\n\\nWith that operation in hand, I just replaced all the angles with their sines and cosines and ran the rotation operator R() instead of calling sin/cos. The code is otherwise identical.\\n\\nGetting rid of float, too\\nWe can use exactly the same ideas with integer fixed-point arithmetic, and not use any float math whatsoever. I’ve redone all the math with 10-bit precision and produced the following C code which runs well on embedded devices which can do 32-bit multiplications and have ~4k of available RAM:\\n\\n#include <stdint.h>\\n#include <stdio.h>\\n#include <string.h>\\n#include <unistd.h>\\n\\n#define R(mul,shift,x,y) \\\\\\n  _=x; \\\\\\n  x -= mul*y>>shift; \\\\\\n  y += mul*_>>shift; \\\\\\n  _ = 3145728-x*x-y*y>>11; \\\\\\n  x = x*_>>10; \\\\\\n  y = y*_>>10;\\n\\nint8_t b[1760], z[1760];\\n\\nvoid main() {\\n  int sA=1024,cA=0,sB=1024,cB=0,_;\\n  for (;;) {\\n    memset(b, 32, 1760);  // text buffer\\n    memset(z, 127, 1760);   // z buffer\\n    int sj=0, cj=1024;\\n    for (int j = 0; j < 90; j++) {\\n      int si = 0, ci = 1024;  // sine and cosine of angle i\\n      for (int i = 0; i < 324; i++) {\\n        int R1 = 1, R2 = 2048, K2 = 5120*1024;\\n\\n        int x0 = R1*cj + R2,\\n            x1 = ci*x0 >> 10,\\n            x2 = cA*sj >> 10,\\n            x3 = si*x0 >> 10,\\n            x4 = R1*x2 - (sA*x3 >> 10),\\n            x5 = sA*sj >> 10,\\n            x6 = K2 + R1*1024*x5 + cA*x3,\\n            x7 = cj*si >> 10,\\n            x = 40 + 30*(cB*x1 - sB*x4)/x6,\\n            y = 12 + 15*(cB*x4 + sB*x1)/x6,\\n            N = (-cA*x7 - cB*((-sA*x7>>10) + x2) - ci*(cj*sB >> 10) >> 10) - x5 >> 7;\\n\\n        int o = x + 80 * y;\\n        int8_t zz = (x6-K2)>>15;\\n        if (22 > y && y > 0 && x > 0 && 80 > x && zz < z[o]) {\\n          z[o] = zz;\\n          b[o] = \\\".,-~:;=!*#$@\\\"[N > 0 ? N : 0];\\n        }\\n        R(5, 8, ci, si)  // rotate i\\n      }\\n      R(9, 7, cj, sj)  // rotate j\\n    }\\n    for (int k = 0; 1761 > k; k++)\\n      putchar(k % 80 ? b[k] : 10);\\n    R(5, 7, cA, sA);\\n    R(5, 8, cB, sB);\\n    usleep(15000);\\n    printf(\\\"\\\\x1b[23A\\\");\\n  }\\n}\\nThe output is pretty much the same.\\n\"}"
}
