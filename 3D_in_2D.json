{
        "title": "3D_in_2D",
        "description": "https://www.basedesign.com/blog/how-to-render-3d-in-2d-canvas",
        "files":["index.html","main.js"],
        "code":"{\"0\":\"{\\n        \\\"title\\\": \\\"index.html\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"code\\\":\\\"<!DOCTYPE html>\\\\n<html lang=\\\\\\\"en\\\\\\\">\\\\n<head>\\\\n    <meta charset=\\\\\\\"UTF-8\\\\\\\">\\\\n    <meta name=\\\\\\\"viewport\\\\\\\" content=\\\\\\\"width=device-width, initial-scale=1.0\\\\\\\">\\\\n    <title>Document</title>\\\\n<style>\\\\n      body{\\\\n       background-color:black; \\\\n      }\\\\n      #scene{\\\\n        width:500px;\\\\n        height:500px;\\\\n        margin-top:15%;\\\\n      }\\\\n</style>\\\\n</head>\\\\n<body>\\\\n  <div style=\\\\\\\"text-align:center;\\\\\\\">\\\\n      <canvas  id=\\\\\\\"scene\\\\\\\"></canvas></div>\\\\n  <script type=\\\\\\\"module\\\\\\\" src=\\\\\\\"main.js\\\\\\\"></script>\\\\n</body>\\\\n</html>\\\"\\n}\",\"1\":\"{\\n        \\\"title\\\": \\\"main.js\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"code\\\":\\\"\\\\n// Get the canvas element from the DOM\\\\nconst canvas = document.getElementById('scene');\\\\ncanvas.width = canvas.clientWidth;\\\\ncanvas.height = canvas.clientHeight;\\\\n// Store the 2D context\\\\nconst ctx = canvas.getContext('2d');\\\\n\\\\nif (window.devicePixelRatio > 1) {\\\\n  canvas.width = canvas.clientWidth * 2;\\\\n  canvas.height = canvas.clientHeight * 2;\\\\n  ctx.scale(2, 2);\\\\n}\\\\n\\\\n/* ====================== */\\\\n/* ====== VARIABLES ===== */\\\\n/* ====================== */\\\\nlet width = canvas.clientWidth; // Width of the canvas\\\\nlet height = canvas.clientHeight; // Height of the canvas\\\\nlet rotation = 0; // Rotation of the globe\\\\nlet dots = []; // Every dots in an array\\\\n\\\\n/* ====================== */\\\\n/* ====== CONSTANTS ===== */\\\\n/* ====================== */\\\\n/* Some of those constants may change if the user resizes their screen but I still strongly believe they belong to the Constants part of the variables */\\\\nconst DOTS_AMOUNT = 1000; // Amount of dots on the screen\\\\nconst DOT_RADIUS = 4; // Radius of the dots\\\\nlet GLOBE_RADIUS = width * 0.7; // Radius of the globe\\\\nlet GLOBE_CENTER_Z = -GLOBE_RADIUS; // Z value of the globe center\\\\nlet PROJECTION_CENTER_X = width / 2; // X center of the canvas HTML\\\\nlet PROJECTION_CENTER_Y = height / 2; // Y center of the canvas HTML\\\\nlet FIELD_OF_VIEW = width * 0.8;\\\\n\\\\nclass Dot {\\\\n  constructor(x, y, z) {\\\\n    this.x = x;\\\\n    this.y = y;\\\\n    this.z = z;\\\\n    \\\\n    this.xProject = 0;\\\\n    this.yProject = 0;\\\\n    this.sizeProjection = 0;\\\\n  }\\\\n  // Do some math to project the 3D position into the 2D canvas\\\\n  project(sin, cos) {\\\\n    const rotX = cos * this.x + sin * (this.z - GLOBE_CENTER_Z);\\\\n    const rotZ = -sin * this.x + cos * (this.z - GLOBE_CENTER_Z) + GLOBE_CENTER_Z;\\\\n    this.sizeProjection = FIELD_OF_VIEW / (FIELD_OF_VIEW - rotZ);\\\\n    this.xProject = (rotX * this.sizeProjection) + PROJECTION_CENTER_X;\\\\n    this.yProject = (this.y * this.sizeProjection) + PROJECTION_CENTER_Y;\\\\n  }\\\\n  // Draw the dot on the canvas\\\\n  draw(sin, cos) {\\\\n    this.project(sin, cos);\\\\n    // ctx.fillRect(this.xProject - DOT_RADIUS, this.yProject - DOT_RADIUS, DOT_RADIUS * 2 * this.sizeProjection, DOT_RADIUS * 2 * this.sizeProjection);\\\\n    ctx.beginPath();\\\\n    ctx.arc(this.xProject, this.yProject, DOT_RADIUS * this.sizeProjection, 0, Math.PI * 2);\\\\n    ctx.closePath();\\\\n    ctx.fillStyle = \\\\\\\"#71e2d7\\\\\\\";\\\\n    ctx.fill();\\\\n  }\\\\n}\\\\n\\\\nfunction createDots() {\\\\n  // Empty the array of dots\\\\n  dots.length = 0;\\\\n  \\\\n  // Create a new dot based on the amount needed\\\\n  for (let i = 0; i < DOTS_AMOUNT; i++) {\\\\n    const theta = Math.random() * 2 * Math.PI; // Random value between [0, 2PI]\\\\n    const phi = Math.acos((Math.random() * 2) - 1); // Random value between [-1, 1]\\\\n    \\\\n    // Calculate the [x, y, z] coordinates of the dot along the globe\\\\n    const x = GLOBE_RADIUS * Math.sin(phi) * Math.cos(theta);\\\\n    const y = GLOBE_RADIUS * Math.sin(phi) * Math.sin(theta);\\\\n    const z = (GLOBE_RADIUS * Math.cos(phi)) + GLOBE_CENTER_Z;\\\\n    dots.push(new Dot(x, y, z));\\\\n  }\\\\n}\\\\n\\\\n/* ====================== */\\\\n/* ======== RENDER ====== */\\\\n/* ====================== */\\\\nfunction render(a) {\\\\n  // Clear the scene\\\\n  ctx.clearRect(0, 0, width, height);\\\\n  \\\\n  // Increase the globe rotation\\\\n  rotation = a * 0.0004;\\\\n  \\\\n  const sineRotation = Math.sin(rotation); // Sine of the rotation\\\\n  const cosineRotation = Math.cos(rotation); // Cosine of the rotation\\\\n  \\\\n  // Loop through the dots array and draw every dot\\\\n  for (var i = 0; i < dots.length; i++) {\\\\n    dots[i].draw(sineRotation, cosineRotation);\\\\n  }\\\\n  \\\\n  window.requestAnimationFrame(render);\\\\n}\\\\n\\\\n\\\\n// Function called after the user resized its screen\\\\nfunction afterResize () {\\\\n  width = canvas.offsetWidth;\\\\n  height = canvas.offsetHeight;\\\\n  if (window.devicePixelRatio > 1) {\\\\n    canvas.width = canvas.clientWidth * 2;\\\\n    canvas.height = canvas.clientHeight * 2;\\\\n    ctx.scale(2, 2);\\\\n  } else {\\\\n    canvas.width = width;\\\\n    canvas.height = height;\\\\n  }\\\\n  GLOBE_RADIUS = width * 0.7;\\\\n  GLOBE_CENTER_Z = -GLOBE_RADIUS;\\\\n  PROJECTION_CENTER_X = width / 2;\\\\n  PROJECTION_CENTER_Y = height / 2;\\\\n  FIELD_OF_VIEW = width * 0.8;\\\\n  \\\\n  createDots(); // Reset all dots\\\\n}\\\\n\\\\n// Variable used to store a timeout when user resized its screen\\\\nlet resizeTimeout;\\\\n// Function called right after user resized its screen\\\\nfunction onResize () {\\\\n  // Clear the timeout variable\\\\n  resizeTimeout = window.clearTimeout(resizeTimeout);\\\\n  // Store a new timeout to avoid calling afterResize for every resize event\\\\n  resizeTimeout = window.setTimeout(afterResize, 500);\\\\n}\\\\nwindow.addEventListener('resize', onResize);\\\\n\\\\n// Populate the dots array with random dots\\\\ncreateDots();\\\\n\\\\n// Render the scene\\\\nwindow.requestAnimationFrame(render);\\\"\\n}\"}"
}
