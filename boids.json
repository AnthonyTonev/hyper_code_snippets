{
        "title": "boids",
        "description": "flocking simulation : https://www.red3d.com/cwr/boids/",
        "files":["boids.js","index.html"],
        "code":"{\"0\":\"// Size of canvas. These get updated to fill the whole browser.\\nlet width = 150;\\nlet height = 150;\\n\\nconst numBoids = 100;\\nconst visualRange = 75;\\n\\nvar boids = [];\\n\\nfunction initBoids() {\\n  for (var i = 0; i < numBoids; i += 1) {\\n    boids[boids.length] = {\\n      x: Math.random() * width,\\n      y: Math.random() * height,\\n      dx: Math.random() * 10 - 5,\\n      dy: Math.random() * 10 - 5,\\n      history: [],\\n    };\\n  }\\n}\\n\\nfunction distance(boid1, boid2) {\\n  return Math.sqrt(\\n    (boid1.x - boid2.x) * (boid1.x - boid2.x) +\\n      (boid1.y - boid2.y) * (boid1.y - boid2.y),\\n  );\\n}\\n\\n// TODO: This is naive and inefficient.\\nfunction nClosestBoids(boid, n) {\\n  // Make a copy\\n  const sorted = boids.slice();\\n  // Sort the copy by distance from `boid`\\n  sorted.sort((a, b) => distance(boid, a) - distance(boid, b));\\n  // Return the `n` closest\\n  return sorted.slice(1, n + 1);\\n}\\n\\n// Called initially and whenever the window resizes to update the canvas\\n// size and width/height variables.\\nfunction sizeCanvas() {\\n  const canvas = document.getElementById(\\\"boids\\\");\\n  width = window.innerWidth;\\n  height = window.innerHeight;\\n  canvas.width = width;\\n  canvas.height = height;\\n}\\n\\n// Constrain a boid to within the window. If it gets too close to an edge,\\n// nudge it back in and reverse its direction.\\nfunction keepWithinBounds(boid) {\\n  const margin = 200;\\n  const turnFactor = 1;\\n\\n  if (boid.x < margin) {\\n    boid.dx += turnFactor;\\n  }\\n  if (boid.x > width - margin) {\\n    boid.dx -= turnFactor\\n  }\\n  if (boid.y < margin) {\\n    boid.dy += turnFactor;\\n  }\\n  if (boid.y > height - margin) {\\n    boid.dy -= turnFactor;\\n  }\\n}\\n\\n// Find the center of mass of the other boids and adjust velocity slightly to\\n// point towards the center of mass.\\nfunction flyTowardsCenter(boid) {\\n  const centeringFactor = 0.005; // adjust velocity by this %\\n\\n  let centerX = 0;\\n  let centerY = 0;\\n  let numNeighbors = 0;\\n\\n  for (let otherBoid of boids) {\\n    if (distance(boid, otherBoid) < visualRange) {\\n      centerX += otherBoid.x;\\n      centerY += otherBoid.y;\\n      numNeighbors += 1;\\n    }\\n  }\\n\\n  if (numNeighbors) {\\n    centerX = centerX / numNeighbors;\\n    centerY = centerY / numNeighbors;\\n\\n    boid.dx += (centerX - boid.x) * centeringFactor;\\n    boid.dy += (centerY - boid.y) * centeringFactor;\\n  }\\n}\\n\\n// Move away from other boids that are too close to avoid colliding\\nfunction avoidOthers(boid) {\\n  const minDistance = 20; // The distance to stay away from other boids\\n  const avoidFactor = 0.05; // Adjust velocity by this %\\n  let moveX = 0;\\n  let moveY = 0;\\n  for (let otherBoid of boids) {\\n    if (otherBoid !== boid) {\\n      if (distance(boid, otherBoid) < minDistance) {\\n        moveX += boid.x - otherBoid.x;\\n        moveY += boid.y - otherBoid.y;\\n      }\\n    }\\n  }\\n\\n  boid.dx += moveX * avoidFactor;\\n  boid.dy += moveY * avoidFactor;\\n}\\n\\n// Find the average velocity (speed and direction) of the other boids and\\n// adjust velocity slightly to match.\\nfunction matchVelocity(boid) {\\n  const matchingFactor = 0.05; // Adjust by this % of average velocity\\n\\n  let avgDX = 0;\\n  let avgDY = 0;\\n  let numNeighbors = 0;\\n\\n  for (let otherBoid of boids) {\\n    if (distance(boid, otherBoid) < visualRange) {\\n      avgDX += otherBoid.dx;\\n      avgDY += otherBoid.dy;\\n      numNeighbors += 1;\\n    }\\n  }\\n\\n  if (numNeighbors) {\\n    avgDX = avgDX / numNeighbors;\\n    avgDY = avgDY / numNeighbors;\\n\\n    boid.dx += (avgDX - boid.dx) * matchingFactor;\\n    boid.dy += (avgDY - boid.dy) * matchingFactor;\\n  }\\n}\\n\\n// Speed will naturally vary in flocking behavior, but real animals can't go\\n// arbitrarily fast.\\nfunction limitSpeed(boid) {\\n  const speedLimit = 15;\\n\\n  const speed = Math.sqrt(boid.dx * boid.dx + boid.dy * boid.dy);\\n  if (speed > speedLimit) {\\n    boid.dx = (boid.dx / speed) * speedLimit;\\n    boid.dy = (boid.dy / speed) * speedLimit;\\n  }\\n}\\n\\nconst DRAW_TRAIL = false;\\n\\nfunction drawBoid(ctx, boid) {\\n  const angle = Math.atan2(boid.dy, boid.dx);\\n  ctx.translate(boid.x, boid.y);\\n  ctx.rotate(angle);\\n  ctx.translate(-boid.x, -boid.y);\\n  ctx.fillStyle = \\\"#71e2d7\\\";\\n  ctx.beginPath();\\n  ctx.moveTo(boid.x, boid.y);\\n  ctx.lineTo(boid.x - 15, boid.y + 5);\\n  ctx.lineTo(boid.x - 15, boid.y - 5);\\n  ctx.lineTo(boid.x, boid.y);\\n  ctx.fill();\\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\\n\\n  if (DRAW_TRAIL) {\\n    ctx.strokeStyle = \\\"#558cf466\\\";\\n    ctx.beginPath();\\n    ctx.moveTo(boid.history[0][0], boid.history[0][1]);\\n    for (const point of boid.history) {\\n      ctx.lineTo(point[0], point[1]);\\n    }\\n    ctx.stroke();\\n  }\\n}\\n\\n// Main animation loop\\nfunction animationLoop() {\\n  // Update each boid\\n  for (let boid of boids) {\\n    // Update the velocities according to each rule\\n    flyTowardsCenter(boid);\\n    avoidOthers(boid);\\n    matchVelocity(boid);\\n    limitSpeed(boid);\\n    keepWithinBounds(boid);\\n\\n    // Update the position based on the current velocity\\n    boid.x += boid.dx;\\n    boid.y += boid.dy;\\n    boid.history.push([boid.x, boid.y])\\n    boid.history = boid.history.slice(-50);\\n  }\\n\\n  // Clear the canvas and redraw all the boids in their current positions\\n  const ctx = document.getElementById(\\\"boids\\\").getContext(\\\"2d\\\");\\n  ctx.clearRect(0, 0, width, height);\\n  for (let boid of boids) {\\n    drawBoid(ctx, boid);\\n  }\\n\\n  // Schedule the next frame\\n  window.requestAnimationFrame(animationLoop);\\n}\\n\\nwindow.onload = () => {\\n  // Make sure the canvas always fills the whole window\\n  window.addEventListener(\\\"resize\\\", sizeCanvas, false);\\n  sizeCanvas();\\n\\n  // Randomly distribute the boids to start\\n  initBoids();\\n\\n  // Schedule the main animation loop\\n  window.requestAnimationFrame(animationLoop);\\n};\",\"1\":\"<!DOCTYPE html>\\n<html>\\n  <head>\\n    <meta charset=\\\"utf-8\\\"/>\\n    <title>Boids</title>\\n    <script src=\\\"./boids.js\\\"></script>\\n    <style type=\\\"text/css\\\">\\n      body {\\n        margin: 0;\\n        background: #282c34;\\n        overflow: hidden;\\n      }\\n    </style>\\n  </head>\\n  <body>\\n    <canvas id=\\\"boids\\\" width=\\\"150\\\" height=\\\"150\\\"></canvas>\\n  </body>\\n</html>\"}"
}
