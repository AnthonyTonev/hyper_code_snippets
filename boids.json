{
        "title": "boids",
        "description": "https://www.red3d.com/cwr/boids/",
        "code":"{\"0\":\"{\\n        \\\"title\\\": \\\"boids.js\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"code\\\":\\\"// Size of canvas. These get updated to fill the whole browser.\\\\nlet width = 150;\\\\nlet height = 150;\\\\n\\\\nconst numBoids = 100;\\\\nconst visualRange = 75;\\\\n\\\\nvar boids = [];\\\\n\\\\nfunction initBoids() {\\\\n  for (var i = 0; i < numBoids; i += 1) {\\\\n    boids[boids.length] = {\\\\n      x: Math.random() * width,\\\\n      y: Math.random() * height,\\\\n      dx: Math.random() * 10 - 5,\\\\n      dy: Math.random() * 10 - 5,\\\\n      history: [],\\\\n    };\\\\n  }\\\\n}\\\\n\\\\nfunction distance(boid1, boid2) {\\\\n  return Math.sqrt(\\\\n    (boid1.x - boid2.x) * (boid1.x - boid2.x) +\\\\n      (boid1.y - boid2.y) * (boid1.y - boid2.y),\\\\n  );\\\\n}\\\\n\\\\n// TODO: This is naive and inefficient.\\\\nfunction nClosestBoids(boid, n) {\\\\n  // Make a copy\\\\n  const sorted = boids.slice();\\\\n  // Sort the copy by distance from `boid`\\\\n  sorted.sort((a, b) => distance(boid, a) - distance(boid, b));\\\\n  // Return the `n` closest\\\\n  return sorted.slice(1, n + 1);\\\\n}\\\\n\\\\n// Called initially and whenever the window resizes to update the canvas\\\\n// size and width/height variables.\\\\nfunction sizeCanvas() {\\\\n  const canvas = document.getElementById(\\\\\\\"boids\\\\\\\");\\\\n  width = window.innerWidth;\\\\n  height = window.innerHeight;\\\\n  canvas.width = width;\\\\n  canvas.height = height;\\\\n}\\\\n\\\\n// Constrain a boid to within the window. If it gets too close to an edge,\\\\n// nudge it back in and reverse its direction.\\\\nfunction keepWithinBounds(boid) {\\\\n  const margin = 200;\\\\n  const turnFactor = 1;\\\\n\\\\n  if (boid.x < margin) {\\\\n    boid.dx += turnFactor;\\\\n  }\\\\n  if (boid.x > width - margin) {\\\\n    boid.dx -= turnFactor\\\\n  }\\\\n  if (boid.y < margin) {\\\\n    boid.dy += turnFactor;\\\\n  }\\\\n  if (boid.y > height - margin) {\\\\n    boid.dy -= turnFactor;\\\\n  }\\\\n}\\\\n\\\\n// Find the center of mass of the other boids and adjust velocity slightly to\\\\n// point towards the center of mass.\\\\nfunction flyTowardsCenter(boid) {\\\\n  const centeringFactor = 0.005; // adjust velocity by this %\\\\n\\\\n  let centerX = 0;\\\\n  let centerY = 0;\\\\n  let numNeighbors = 0;\\\\n\\\\n  for (let otherBoid of boids) {\\\\n    if (distance(boid, otherBoid) < visualRange) {\\\\n      centerX += otherBoid.x;\\\\n      centerY += otherBoid.y;\\\\n      numNeighbors += 1;\\\\n    }\\\\n  }\\\\n\\\\n  if (numNeighbors) {\\\\n    centerX = centerX / numNeighbors;\\\\n    centerY = centerY / numNeighbors;\\\\n\\\\n    boid.dx += (centerX - boid.x) * centeringFactor;\\\\n    boid.dy += (centerY - boid.y) * centeringFactor;\\\\n  }\\\\n}\\\\n\\\\n// Move away from other boids that are too close to avoid colliding\\\\nfunction avoidOthers(boid) {\\\\n  const minDistance = 20; // The distance to stay away from other boids\\\\n  const avoidFactor = 0.05; // Adjust velocity by this %\\\\n  let moveX = 0;\\\\n  let moveY = 0;\\\\n  for (let otherBoid of boids) {\\\\n    if (otherBoid !== boid) {\\\\n      if (distance(boid, otherBoid) < minDistance) {\\\\n        moveX += boid.x - otherBoid.x;\\\\n        moveY += boid.y - otherBoid.y;\\\\n      }\\\\n    }\\\\n  }\\\\n\\\\n  boid.dx += moveX * avoidFactor;\\\\n  boid.dy += moveY * avoidFactor;\\\\n}\\\\n\\\\n// Find the average velocity (speed and direction) of the other boids and\\\\n// adjust velocity slightly to match.\\\\nfunction matchVelocity(boid) {\\\\n  const matchingFactor = 0.05; // Adjust by this % of average velocity\\\\n\\\\n  let avgDX = 0;\\\\n  let avgDY = 0;\\\\n  let numNeighbors = 0;\\\\n\\\\n  for (let otherBoid of boids) {\\\\n    if (distance(boid, otherBoid) < visualRange) {\\\\n      avgDX += otherBoid.dx;\\\\n      avgDY += otherBoid.dy;\\\\n      numNeighbors += 1;\\\\n    }\\\\n  }\\\\n\\\\n  if (numNeighbors) {\\\\n    avgDX = avgDX / numNeighbors;\\\\n    avgDY = avgDY / numNeighbors;\\\\n\\\\n    boid.dx += (avgDX - boid.dx) * matchingFactor;\\\\n    boid.dy += (avgDY - boid.dy) * matchingFactor;\\\\n  }\\\\n}\\\\n\\\\n// Speed will naturally vary in flocking behavior, but real animals can't go\\\\n// arbitrarily fast.\\\\nfunction limitSpeed(boid) {\\\\n  const speedLimit = 15;\\\\n\\\\n  const speed = Math.sqrt(boid.dx * boid.dx + boid.dy * boid.dy);\\\\n  if (speed > speedLimit) {\\\\n    boid.dx = (boid.dx / speed) * speedLimit;\\\\n    boid.dy = (boid.dy / speed) * speedLimit;\\\\n  }\\\\n}\\\\n\\\\nconst DRAW_TRAIL = false;\\\\n\\\\nfunction drawBoid(ctx, boid) {\\\\n  const angle = Math.atan2(boid.dy, boid.dx);\\\\n  ctx.translate(boid.x, boid.y);\\\\n  ctx.rotate(angle);\\\\n  ctx.translate(-boid.x, -boid.y);\\\\n  ctx.fillStyle = \\\\\\\"#71e2d7\\\\\\\";\\\\n  ctx.beginPath();\\\\n  ctx.moveTo(boid.x, boid.y);\\\\n  ctx.lineTo(boid.x - 15, boid.y + 5);\\\\n  ctx.lineTo(boid.x - 15, boid.y - 5);\\\\n  ctx.lineTo(boid.x, boid.y);\\\\n  ctx.fill();\\\\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\\\\n\\\\n  if (DRAW_TRAIL) {\\\\n    ctx.strokeStyle = \\\\\\\"#558cf466\\\\\\\";\\\\n    ctx.beginPath();\\\\n    ctx.moveTo(boid.history[0][0], boid.history[0][1]);\\\\n    for (const point of boid.history) {\\\\n      ctx.lineTo(point[0], point[1]);\\\\n    }\\\\n    ctx.stroke();\\\\n  }\\\\n}\\\\n\\\\n// Main animation loop\\\\nfunction animationLoop() {\\\\n  // Update each boid\\\\n  for (let boid of boids) {\\\\n    // Update the velocities according to each rule\\\\n    flyTowardsCenter(boid);\\\\n    avoidOthers(boid);\\\\n    matchVelocity(boid);\\\\n    limitSpeed(boid);\\\\n    keepWithinBounds(boid);\\\\n\\\\n    // Update the position based on the current velocity\\\\n    boid.x += boid.dx;\\\\n    boid.y += boid.dy;\\\\n    boid.history.push([boid.x, boid.y])\\\\n    boid.history = boid.history.slice(-50);\\\\n  }\\\\n\\\\n  // Clear the canvas and redraw all the boids in their current positions\\\\n  const ctx = document.getElementById(\\\\\\\"boids\\\\\\\").getContext(\\\\\\\"2d\\\\\\\");\\\\n  ctx.clearRect(0, 0, width, height);\\\\n  for (let boid of boids) {\\\\n    drawBoid(ctx, boid);\\\\n  }\\\\n\\\\n  // Schedule the next frame\\\\n  window.requestAnimationFrame(animationLoop);\\\\n}\\\\n\\\\nwindow.onload = () => {\\\\n  // Make sure the canvas always fills the whole window\\\\n  window.addEventListener(\\\\\\\"resize\\\\\\\", sizeCanvas, false);\\\\n  sizeCanvas();\\\\n\\\\n  // Randomly distribute the boids to start\\\\n  initBoids();\\\\n\\\\n  // Schedule the main animation loop\\\\n  window.requestAnimationFrame(animationLoop);\\\\n};\\\"\\n}\",\"1\":\"{\\n        \\\"title\\\": \\\"index.html\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"code\\\":\\\"<!DOCTYPE html>\\\\n<html>\\\\n  <head>\\\\n    <meta charset=\\\\\\\"utf-8\\\\\\\"/>\\\\n    <title>Boids</title>\\\\n    <script src=\\\\\\\"./boids.js\\\\\\\"></script>\\\\n    <style type=\\\\\\\"text/css\\\\\\\">\\\\n      body {\\\\n        margin: 0;\\\\n        background: #282c34;\\\\n        overflow: hidden;\\\\n      }\\\\n    </style>\\\\n  </head>\\\\n  <body>\\\\n    <canvas id=\\\\\\\"boids\\\\\\\" width=\\\\\\\"150\\\\\\\" height=\\\\\\\"150\\\\\\\"></canvas>\\\\n  </body>\\\\n</html>\\\"\\n}\"}"
}
