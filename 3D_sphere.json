{
        "title": "3D_sphere",
        "description": "3d in 2d",
        "files":["index.html","main.js"],
        "code":"{\"0\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n    <meta charset=\\\"UTF-8\\\">\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n    <title>Document</title>\\n<style>\\n      body{\\n       background-color:black; \\n      }\\n      #scene{\\n        width:500px;\\n        height:500px;\\n        margin-top:15%;\\n      }\\n</style>\\n</head>\\n<body>\\n  <div style=\\\"text-align:center;\\\">\\n      <canvas  id=\\\"scene\\\"></canvas></div>\\n  <script type=\\\"module\\\" src=\\\"main.js\\\"></script>\\n</body>\\n</html>\",\"1\":\"\\n// Get the canvas element from the DOM\\nconst canvas = document.getElementById('scene');\\ncanvas.width = canvas.clientWidth;\\ncanvas.height = canvas.clientHeight;\\n// Store the 2D context\\nconst ctx = canvas.getContext('2d');\\n\\nif (window.devicePixelRatio > 1) {\\n  canvas.width = canvas.clientWidth * 2;\\n  canvas.height = canvas.clientHeight * 2;\\n  ctx.scale(2, 2);\\n}\\n\\n/* ====================== */\\n/* ====== VARIABLES ===== */\\n/* ====================== */\\nlet width = canvas.clientWidth; // Width of the canvas\\nlet height = canvas.clientHeight; // Height of the canvas\\nlet rotation = 0; // Rotation of the globe\\nlet dots = []; // Every dots in an array\\n\\n/* ====================== */\\n/* ====== CONSTANTS ===== */\\n/* ====================== */\\n/* Some of those constants may change if the user resizes their screen but I still strongly believe they belong to the Constants part of the variables */\\nconst DOTS_AMOUNT = 1000; // Amount of dots on the screen\\nconst DOT_RADIUS = 4; // Radius of the dots\\nlet GLOBE_RADIUS = width * 0.7; // Radius of the globe\\nlet GLOBE_CENTER_Z = -GLOBE_RADIUS; // Z value of the globe center\\nlet PROJECTION_CENTER_X = width / 2; // X center of the canvas HTML\\nlet PROJECTION_CENTER_Y = height / 2; // Y center of the canvas HTML\\nlet FIELD_OF_VIEW = width * 0.8;\\n\\nclass Dot {\\n  constructor(x, y, z) {\\n    this.x = x;\\n    this.y = y;\\n    this.z = z;\\n    \\n    this.xProject = 0;\\n    this.yProject = 0;\\n    this.sizeProjection = 0;\\n  }\\n  // Do some math to project the 3D position into the 2D canvas\\n  project(sin, cos) {\\n    const rotX = cos * this.x + sin * (this.z - GLOBE_CENTER_Z);\\n    const rotZ = -sin * this.x + cos * (this.z - GLOBE_CENTER_Z) + GLOBE_CENTER_Z;\\n    this.sizeProjection = FIELD_OF_VIEW / (FIELD_OF_VIEW - rotZ);\\n    this.xProject = (rotX * this.sizeProjection) + PROJECTION_CENTER_X;\\n    this.yProject = (this.y * this.sizeProjection) + PROJECTION_CENTER_Y;\\n  }\\n  // Draw the dot on the canvas\\n  draw(sin, cos) {\\n    this.project(sin, cos);\\n    // ctx.fillRect(this.xProject - DOT_RADIUS, this.yProject - DOT_RADIUS, DOT_RADIUS * 2 * this.sizeProjection, DOT_RADIUS * 2 * this.sizeProjection);\\n    ctx.beginPath();\\n    ctx.arc(this.xProject, this.yProject, DOT_RADIUS * this.sizeProjection, 0, Math.PI * 2);\\n    ctx.closePath();\\n    ctx.fillStyle = \\\"#71e2d7\\\";\\n    ctx.fill();\\n  }\\n}\\n\\nfunction createDots() {\\n  // Empty the array of dots\\n  dots.length = 0;\\n  \\n  // Create a new dot based on the amount needed\\n  for (let i = 0; i < DOTS_AMOUNT; i++) {\\n    const theta = Math.random() * 2 * Math.PI; // Random value between [0, 2PI]\\n    const phi = Math.acos((Math.random() * 2) - 1); // Random value between [-1, 1]\\n    \\n    // Calculate the [x, y, z] coordinates of the dot along the globe\\n    const x = GLOBE_RADIUS * Math.sin(phi) * Math.cos(theta);\\n    const y = GLOBE_RADIUS * Math.sin(phi) * Math.sin(theta);\\n    const z = (GLOBE_RADIUS * Math.cos(phi)) + GLOBE_CENTER_Z;\\n    dots.push(new Dot(x, y, z));\\n  }\\n}\\n\\n/* ====================== */\\n/* ======== RENDER ====== */\\n/* ====================== */\\nfunction render(a) {\\n  // Clear the scene\\n  ctx.clearRect(0, 0, width, height);\\n  \\n  // Increase the globe rotation\\n  rotation = a * 0.0004;\\n  \\n  const sineRotation = Math.sin(rotation); // Sine of the rotation\\n  const cosineRotation = Math.cos(rotation); // Cosine of the rotation\\n  \\n  // Loop through the dots array and draw every dot\\n  for (var i = 0; i < dots.length; i++) {\\n    dots[i].draw(sineRotation, cosineRotation);\\n  }\\n  \\n  window.requestAnimationFrame(render);\\n}\\n\\n\\n// Function called after the user resized its screen\\nfunction afterResize () {\\n  width = canvas.offsetWidth;\\n  height = canvas.offsetHeight;\\n  if (window.devicePixelRatio > 1) {\\n    canvas.width = canvas.clientWidth * 2;\\n    canvas.height = canvas.clientHeight * 2;\\n    ctx.scale(2, 2);\\n  } else {\\n    canvas.width = width;\\n    canvas.height = height;\\n  }\\n  GLOBE_RADIUS = width * 0.7;\\n  GLOBE_CENTER_Z = -GLOBE_RADIUS;\\n  PROJECTION_CENTER_X = width / 2;\\n  PROJECTION_CENTER_Y = height / 2;\\n  FIELD_OF_VIEW = width * 0.8;\\n  \\n  createDots(); // Reset all dots\\n}\\n\\n// Variable used to store a timeout when user resized its screen\\nlet resizeTimeout;\\n// Function called right after user resized its screen\\nfunction onResize () {\\n  // Clear the timeout variable\\n  resizeTimeout = window.clearTimeout(resizeTimeout);\\n  // Store a new timeout to avoid calling afterResize for every resize event\\n  resizeTimeout = window.setTimeout(afterResize, 500);\\n}\\nwindow.addEventListener('resize', onResize);\\n\\n// Populate the dots array with random dots\\ncreateDots();\\n\\n// Render the scene\\nwindow.requestAnimationFrame(render);\"}"
}
