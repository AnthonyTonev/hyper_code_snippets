{
        "title": "template_test",
        "description": "",
        "files":["donut_index.html","donut_main.js","index.html","bird_boids.js","bird_index.html","globe_index.html","globe_main.js"],
        "code":"{\"0\":\"{\\n        \\\"title\\\": \\\"donut_index.html\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"code\\\":\\\"<!DOCTYPE html>\\\\n<html lang=\\\\\\\"en\\\\\\\">\\\\n  <style>\\\\n  body{\\\\n  background-color:black;\\\\n  }\\\\n  </style>\\\\n<head>\\\\n    <meta charset=\\\\\\\"UTF-8\\\\\\\">\\\\n    <meta name=\\\\\\\"viewport\\\\\\\" content=\\\\\\\"width=device-width, initial-scale=1.0\\\\\\\">\\\\n    <title>Document</title>\\\\n</head>\\\\n<body>\\\\n  <script type=\\\\\\\"module\\\\\\\" src=\\\\\\\"donut_main.js\\\\\\\"></script>\\\\n</body>\\\\n</html>\\\"\\n}\",\"1\":\"{\\n        \\\"title\\\": \\\"donut_main.js\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"code\\\":\\\"const donut = function() {\\\\n  const pretag = document.createElement(\\\\\\\"pre\\\\\\\");\\\\n  pretag.style = \\\\\\\"background:transparent;color:#ffddad;position:absolute;top:25%;z_index:-1000;\\\\\\\";\\\\n  document.body.appendChild(pretag);\\\\n\\\\n  let tmr1 = undefined, tmr2 = undefined;\\\\n  let A=1, B=1;\\\\n\\\\n  const asciiframe=function() {\\\\n    const b=[];\\\\n    const z=[];\\\\n    A += 0.07;\\\\n    B += 0.03;\\\\n    const cA=Math.cos(A), sA=Math.sin(A),\\\\n        cB=Math.cos(B), sB=Math.sin(B);\\\\n    for(let k=0;k<1760;k++) {\\\\n      b[k]=k%80 == 79 ? \\\\\\\"\\\\\\\\n\\\\\\\" : \\\\\\\" \\\\\\\";\\\\n      z[k]=0;\\\\n    }\\\\n    for(let j=0;j<6.28;j+=0.07) { // j <=> theta\\\\n      const ct=Math.cos(j),st=Math.sin(j);\\\\n      for(let i=0;i<6.28;i+=0.02) {   // i <=> phi\\\\n        const sp=Math.sin(i),cp=Math.cos(i),\\\\n            h=ct+2, // R1 + R2*cos(theta)\\\\n            D=1/(sp*h*sA+st*cA+5), // this is 1/z\\\\n            t=sp*h*cA-st*sA; // this is a clever factoring of some of the terms in x' and y'\\\\n\\\\n        const x=0|(40+30*D*(cp*h*cB-t*sB)),\\\\n            y=0|(12+15*D*(cp*h*sB+t*cB)),\\\\n            o=x+80*y,\\\\n            N=0|(8*((st*sA-sp*ct*cA)*cB-sp*ct*sA-st*cA-cp*ct*sB));\\\\n        if(y<22 && y>=0 && x>=0 && x<79 && D>z[o])\\\\n        {\\\\n          z[o]=D;\\\\n          b[o]=\\\\\\\".,-~:;=!*#$@\\\\\\\"[N>0?N:0];\\\\n        }\\\\n      }\\\\n    }\\\\n    pretag.innerHTML = b.join(\\\\\\\"\\\\\\\");\\\\n  };\\\\n\\\\n\\\\n\\\\nsetInterval(asciiframe, 35);\\\\n  asciiframe();\\\\n}\\\\ndonut();\\\\n\\\\n\\\"\\n}\",\"2\":\"{\\n        \\\"title\\\": \\\"index.html\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"code\\\":\\\"<!DOCTYPE html>\\\\n<html>\\\\n  <head>\\\\n    <meta charset=\\\\\\\"utf-8\\\\\\\"/>\\\\n    <title>Boids</title>\\\\n  \\\\n  \\\\n    <style type=\\\\\\\"text/css\\\\\\\">\\\\n      body {\\\\n        margin: 0;\\\\n        background: #282c34;\\\\n      \\\\toverflow:hidden;\\\\n      }\\\\n    </style>\\\\n  </head>\\\\n  <body>\\\\n        <canvas  id=\\\\\\\"scene\\\\\\\" \\\\nstyle=\\\\\\\"position:absolute;z_index:3000;width:20%;height:100%;left:55%;top:-35%;\\\\\\\"></canvas>\\\\n       <canvas id=\\\\\\\"boids\\\\\\\" width=\\\\\\\"50px\\\\\\\" height=\\\\\\\"50px\\\\\\\"></canvas>\\\\n        \\\\n        <script src=\\\\\\\"./bird_boids.js\\\\\\\"></script>\\\\n      <script type=\\\\\\\"module\\\\\\\" src=\\\\\\\"./donut_main.js\\\\\\\"></script>\\\\n  <script type=\\\\\\\"module\\\\\\\" src=\\\\\\\"globe_main.js\\\\\\\"></script>\\\\n   \\\\n\\\\n  </body>\\\\n</html>\\\\n\\\\n\\\"\\n}\",\"3\":\"{\\n        \\\"title\\\": \\\"bird_boids.js\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"code\\\":\\\"// Size of canvas. These get updated to fill the whole browser.\\\\nlet width = 150;\\\\nlet height = 150;\\\\n\\\\nconst numBoids = 100;\\\\nconst visualRange = 75;\\\\n\\\\nvar boids = [];\\\\n\\\\nfunction initBoids() {\\\\n  for (var i = 0; i < numBoids; i += 1) {\\\\n    boids[boids.length] = {\\\\n      x: Math.random() * width,\\\\n      y: Math.random() * height,\\\\n      dx: Math.random() * 10 - 5,\\\\n      dy: Math.random() * 10 - 5,\\\\n      history: [],\\\\n    };\\\\n  }\\\\n}\\\\n\\\\nfunction distance(boid1, boid2) {\\\\n  return Math.sqrt(\\\\n    (boid1.x - boid2.x) * (boid1.x - boid2.x) +\\\\n      (boid1.y - boid2.y) * (boid1.y - boid2.y),\\\\n  );\\\\n}\\\\n\\\\n// TODO: This is naive and inefficient.\\\\nfunction nClosestBoids(boid, n) {\\\\n  // Make a copy\\\\n  const sorted = boids.slice();\\\\n  // Sort the copy by distance from `boid`\\\\n  sorted.sort((a, b) => distance(boid, a) - distance(boid, b));\\\\n  // Return the `n` closest\\\\n  return sorted.slice(1, n + 1);\\\\n}\\\\n\\\\n// Called initially and whenever the window resizes to update the canvas\\\\n// size and width/height variables.\\\\nfunction sizeCanvas() {\\\\n  const canvas = document.getElementById(\\\\\\\"boids\\\\\\\");\\\\n  width = window.innerWidth;\\\\n  height = window.innerHeight;\\\\n  canvas.width = width;\\\\n  canvas.height = height;\\\\n}\\\\n\\\\n// Constrain a boid to within the window. If it gets too close to an edge,\\\\n// nudge it back in and reverse its direction.\\\\nfunction keepWithinBounds(boid) {\\\\n  const margin = 200;\\\\n  const turnFactor = 1;\\\\n\\\\n  if (boid.x < margin) {\\\\n    boid.dx += turnFactor;\\\\n  }\\\\n  if (boid.x > width - margin) {\\\\n    boid.dx -= turnFactor\\\\n  }\\\\n  if (boid.y < margin) {\\\\n    boid.dy += turnFactor;\\\\n  }\\\\n  if (boid.y > height - margin) {\\\\n    boid.dy -= turnFactor;\\\\n  }\\\\n}\\\\n\\\\n// Find the center of mass of the other boids and adjust velocity slightly to\\\\n// point towards the center of mass.\\\\nfunction flyTowardsCenter(boid) {\\\\n  const centeringFactor = 0.005; // adjust velocity by this %\\\\n\\\\n  let centerX = 0;\\\\n  let centerY = 0;\\\\n  let numNeighbors = 0;\\\\n\\\\n  for (let otherBoid of boids) {\\\\n    if (distance(boid, otherBoid) < visualRange) {\\\\n      centerX += otherBoid.x;\\\\n      centerY += otherBoid.y;\\\\n      numNeighbors += 1;\\\\n    }\\\\n  }\\\\n\\\\n  if (numNeighbors) {\\\\n    centerX = centerX / numNeighbors;\\\\n    centerY = centerY / numNeighbors;\\\\n\\\\n    boid.dx += (centerX - boid.x) * centeringFactor;\\\\n    boid.dy += (centerY - boid.y) * centeringFactor;\\\\n  }\\\\n}\\\\n\\\\n// Move away from other boids that are too close to avoid colliding\\\\nfunction avoidOthers(boid) {\\\\n  const minDistance = 20; // The distance to stay away from other boids\\\\n  const avoidFactor = 0.05; // Adjust velocity by this %\\\\n  let moveX = 0;\\\\n  let moveY = 0;\\\\n  for (let otherBoid of boids) {\\\\n    if (otherBoid !== boid) {\\\\n      if (distance(boid, otherBoid) < minDistance) {\\\\n        moveX += boid.x - otherBoid.x;\\\\n        moveY += boid.y - otherBoid.y;\\\\n      }\\\\n    }\\\\n  }\\\\n\\\\n  boid.dx += moveX * avoidFactor;\\\\n  boid.dy += moveY * avoidFactor;\\\\n}\\\\n\\\\n// Find the average velocity (speed and direction) of the other boids and\\\\n// adjust velocity slightly to match.\\\\nfunction matchVelocity(boid) {\\\\n  const matchingFactor = 0.05; // Adjust by this % of average velocity\\\\n\\\\n  let avgDX = 0;\\\\n  let avgDY = 0;\\\\n  let numNeighbors = 0;\\\\n\\\\n  for (let otherBoid of boids) {\\\\n    if (distance(boid, otherBoid) < visualRange) {\\\\n      avgDX += otherBoid.dx;\\\\n      avgDY += otherBoid.dy;\\\\n      numNeighbors += 1;\\\\n    }\\\\n  }\\\\n\\\\n  if (numNeighbors) {\\\\n    avgDX = avgDX / numNeighbors;\\\\n    avgDY = avgDY / numNeighbors;\\\\n\\\\n    boid.dx += (avgDX - boid.dx) * matchingFactor;\\\\n    boid.dy += (avgDY - boid.dy) * matchingFactor;\\\\n  }\\\\n}\\\\n\\\\n// Speed will naturally vary in flocking behavior, but real animals can't go\\\\n// arbitrarily fast.\\\\nfunction limitSpeed(boid) {\\\\n  const speedLimit = 15;\\\\n\\\\n  const speed = Math.sqrt(boid.dx * boid.dx + boid.dy * boid.dy);\\\\n  if (speed > speedLimit) {\\\\n    boid.dx = (boid.dx / speed) * speedLimit;\\\\n    boid.dy = (boid.dy / speed) * speedLimit;\\\\n  }\\\\n}\\\\n\\\\nconst DRAW_TRAIL = false;\\\\n\\\\nfunction drawBoid(ctx, boid) {\\\\n  const angle = Math.atan2(boid.dy, boid.dx);\\\\n  ctx.translate(boid.x, boid.y);\\\\n  ctx.rotate(angle);\\\\n  ctx.translate(-boid.x, -boid.y);\\\\n  ctx.fillStyle = \\\\\\\"#71e2d7\\\\\\\";\\\\n  ctx.beginPath();\\\\n  ctx.moveTo(boid.x, boid.y);\\\\n  ctx.lineTo(boid.x - 15, boid.y + 5);\\\\n  ctx.lineTo(boid.x - 15, boid.y - 5);\\\\n  ctx.lineTo(boid.x, boid.y);\\\\n  ctx.fill();\\\\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\\\\n\\\\n  if (DRAW_TRAIL) {\\\\n    ctx.strokeStyle = \\\\\\\"#558cf466\\\\\\\";\\\\n    ctx.beginPath();\\\\n    ctx.moveTo(boid.history[0][0], boid.history[0][1]);\\\\n    for (const point of boid.history) {\\\\n      ctx.lineTo(point[0], point[1]);\\\\n    }\\\\n    ctx.stroke();\\\\n  }\\\\n}\\\\n\\\\n// Main animation loop\\\\nfunction animationLoop() {\\\\n  // Update each boid\\\\n  for (let boid of boids) {\\\\n    // Update the velocities according to each rule\\\\n    flyTowardsCenter(boid);\\\\n    avoidOthers(boid);\\\\n    matchVelocity(boid);\\\\n    limitSpeed(boid);\\\\n    keepWithinBounds(boid);\\\\n\\\\n    // Update the position based on the current velocity\\\\n    boid.x += boid.dx;\\\\n    boid.y += boid.dy;\\\\n    boid.history.push([boid.x, boid.y])\\\\n    boid.history = boid.history.slice(-50);\\\\n  }\\\\n\\\\n  // Clear the canvas and redraw all the boids in their current positions\\\\n  const ctx = document.getElementById(\\\\\\\"boids\\\\\\\").getContext(\\\\\\\"2d\\\\\\\");\\\\n  ctx.clearRect(0, 0, width, height);\\\\n  for (let boid of boids) {\\\\n    drawBoid(ctx, boid);\\\\n  }\\\\n\\\\n  // Schedule the next frame\\\\n  window.requestAnimationFrame(animationLoop);\\\\n}\\\\n\\\\nwindow.onload = () => {\\\\n  // Make sure the canvas always fills the whole window\\\\n  window.addEventListener(\\\\\\\"resize\\\\\\\", sizeCanvas, false);\\\\n  sizeCanvas();\\\\n\\\\n  // Randomly distribute the boids to start\\\\n  initBoids();\\\\n\\\\n  // Schedule the main animation loop\\\\n  window.requestAnimationFrame(animationLoop);\\\\n};\\\"\\n}\",\"4\":\"{\\n        \\\"title\\\": \\\"bird_index.html\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"code\\\":\\\"<!DOCTYPE html>\\\\n<html>\\\\n  <head>\\\\n    <meta charset=\\\\\\\"utf-8\\\\\\\"/>\\\\n    <title>Boids</title>\\\\n    <script src=\\\\\\\"./bird_boids.js\\\\\\\"></script>\\\\n    <style type=\\\\\\\"text/css\\\\\\\">\\\\n      body {\\\\n        margin: 0;\\\\n        background: #282c34;\\\\n        overflow: hidden;\\\\n      }\\\\n    </style>\\\\n  </head>\\\\n  <body>\\\\n    <canvas id=\\\\\\\"boids\\\\\\\" width=\\\\\\\"150\\\\\\\" height=\\\\\\\"150\\\\\\\"></canvas>\\\\n  </body>\\\\n</html>\\\"\\n}\",\"5\":\"{\\n        \\\"title\\\": \\\"globe_index.html\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"code\\\":\\\"<!DOCTYPE html>\\\\n<html lang=\\\\\\\"en\\\\\\\">\\\\n<head>\\\\n    <meta charset=\\\\\\\"UTF-8\\\\\\\">\\\\n    <meta name=\\\\\\\"viewport\\\\\\\" content=\\\\\\\"width=device-width, initial-scale=1.0\\\\\\\">\\\\n    <title>Document</title>\\\\n<style>\\\\n      body{\\\\n       background-color:black; \\\\n      }\\\\n      #scene{\\\\n        width:500px;\\\\n        height:500px;\\\\n        margin-top:15%;\\\\n      }\\\\n</style>\\\\n</head>\\\\n<body>\\\\n  <div style=\\\\\\\"text-align:center;\\\\\\\">\\\\n      <canvas  id=\\\\\\\"scene\\\\\\\"></canvas></div>\\\\n  <script type=\\\\\\\"module\\\\\\\" src=\\\\\\\"globe_main.js\\\\\\\"></script>\\\\n</body>\\\\n</html>\\\"\\n}\",\"6\":\"{\\n        \\\"title\\\": \\\"globe_main.js\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"code\\\":\\\"\\\\n// Get the canvas element from the DOM\\\\nconst canvas = document.getElementById('scene');\\\\ncanvas.width = canvas.clientWidth;\\\\ncanvas.height = canvas.clientHeight;\\\\n// Store the 2D context\\\\nconst ctx = canvas.getContext('2d');\\\\n\\\\nif (window.devicePixelRatio > 1) {\\\\n  canvas.width = canvas.clientWidth * 2;\\\\n  canvas.height = canvas.clientHeight * 2;\\\\n  ctx.scale(2, 2);\\\\n}\\\\n\\\\n/* ====================== */\\\\n/* ====== VARIABLES ===== */\\\\n/* ====================== */\\\\nlet width = canvas.clientWidth; // Width of the canvas\\\\nlet height = canvas.clientHeight; // Height of the canvas\\\\nlet rotation = 0; // Rotation of the globe\\\\nlet dots = []; // Every dots in an array\\\\n\\\\n/* ====================== */\\\\n/* ====== CONSTANTS ===== */\\\\n/* ====================== */\\\\n/* Some of those constants may change if the user resizes their screen but I still strongly believe they belong to the Constants part of the variables */\\\\nconst DOTS_AMOUNT = 1000; // Amount of dots on the screen\\\\nconst DOT_RADIUS = 4; // Radius of the dots\\\\nlet GLOBE_RADIUS = width * 0.7; // Radius of the globe\\\\nlet GLOBE_CENTER_Z = -GLOBE_RADIUS; // Z value of the globe center\\\\nlet PROJECTION_CENTER_X = width / 2; // X center of the canvas HTML\\\\nlet PROJECTION_CENTER_Y = height / 2; // Y center of the canvas HTML\\\\nlet FIELD_OF_VIEW = width * 0.8;\\\\n\\\\nclass Dot {\\\\n  constructor(x, y, z) {\\\\n    this.x = x;\\\\n    this.y = y;\\\\n    this.z = z;\\\\n    \\\\n    this.xProject = 0;\\\\n    this.yProject = 0;\\\\n    this.sizeProjection = 0;\\\\n  }\\\\n  // Do some math to project the 3D position into the 2D canvas\\\\n  project(sin, cos) {\\\\n    const rotX = cos * this.x + sin * (this.z - GLOBE_CENTER_Z);\\\\n    const rotZ = -sin * this.x + cos * (this.z - GLOBE_CENTER_Z) + GLOBE_CENTER_Z;\\\\n    this.sizeProjection = FIELD_OF_VIEW / (FIELD_OF_VIEW - rotZ);\\\\n    this.xProject = (rotX * this.sizeProjection) + PROJECTION_CENTER_X;\\\\n    this.yProject = (this.y * this.sizeProjection) + PROJECTION_CENTER_Y;\\\\n  }\\\\n  // Draw the dot on the canvas\\\\n  draw(sin, cos) {\\\\n    this.project(sin, cos);\\\\n    // ctx.fillRect(this.xProject - DOT_RADIUS, this.yProject - DOT_RADIUS, DOT_RADIUS * 2 * this.sizeProjection, DOT_RADIUS * 2 * this.sizeProjection);\\\\n    ctx.beginPath();\\\\n    ctx.arc(this.xProject, this.yProject, DOT_RADIUS * this.sizeProjection, 0, Math.PI * 2);\\\\n    ctx.closePath();\\\\n    ctx.fillStyle = \\\\\\\"#71e2d7\\\\\\\";\\\\n    ctx.fill();\\\\n  }\\\\n}\\\\n\\\\nfunction createDots() {\\\\n  // Empty the array of dots\\\\n  dots.length = 0;\\\\n  \\\\n  // Create a new dot based on the amount needed\\\\n  for (let i = 0; i < DOTS_AMOUNT; i++) {\\\\n    const theta = Math.random() * 2 * Math.PI; // Random value between [0, 2PI]\\\\n    const phi = Math.acos((Math.random() * 2) - 1); // Random value between [-1, 1]\\\\n    \\\\n    // Calculate the [x, y, z] coordinates of the dot along the globe\\\\n    const x = GLOBE_RADIUS * Math.sin(phi) * Math.cos(theta);\\\\n    const y = GLOBE_RADIUS * Math.sin(phi) * Math.sin(theta);\\\\n    const z = (GLOBE_RADIUS * Math.cos(phi)) + GLOBE_CENTER_Z;\\\\n    dots.push(new Dot(x, y, z));\\\\n  }\\\\n}\\\\n\\\\n/* ====================== */\\\\n/* ======== RENDER ====== */\\\\n/* ====================== */\\\\nfunction render(a) {\\\\n  // Clear the scene\\\\n  ctx.clearRect(0, 0, width, height);\\\\n  \\\\n  // Increase the globe rotation\\\\n  rotation = a * 0.0004;\\\\n  \\\\n  const sineRotation = Math.sin(rotation); // Sine of the rotation\\\\n  const cosineRotation = Math.cos(rotation); // Cosine of the rotation\\\\n  \\\\n  // Loop through the dots array and draw every dot\\\\n  for (var i = 0; i < dots.length; i++) {\\\\n    dots[i].draw(sineRotation, cosineRotation);\\\\n  }\\\\n  \\\\n  window.requestAnimationFrame(render);\\\\n}\\\\n\\\\n\\\\n// Function called after the user resized its screen\\\\nfunction afterResize () {\\\\n  width = canvas.offsetWidth;\\\\n  height = canvas.offsetHeight;\\\\n  if (window.devicePixelRatio > 1) {\\\\n    canvas.width = canvas.clientWidth * 2;\\\\n    canvas.height = canvas.clientHeight * 2;\\\\n    ctx.scale(2, 2);\\\\n  } else {\\\\n    canvas.width = width;\\\\n    canvas.height = height;\\\\n  }\\\\n  GLOBE_RADIUS = width * 0.7;\\\\n  GLOBE_CENTER_Z = -GLOBE_RADIUS;\\\\n  PROJECTION_CENTER_X = width / 2;\\\\n  PROJECTION_CENTER_Y = height / 2;\\\\n  FIELD_OF_VIEW = width * 0.8;\\\\n  \\\\n  createDots(); // Reset all dots\\\\n}\\\\n\\\\n// Variable used to store a timeout when user resized its screen\\\\nlet resizeTimeout;\\\\n// Function called right after user resized its screen\\\\nfunction onResize () {\\\\n  // Clear the timeout variable\\\\n  resizeTimeout = window.clearTimeout(resizeTimeout);\\\\n  // Store a new timeout to avoid calling afterResize for every resize event\\\\n  resizeTimeout = window.setTimeout(afterResize, 500);\\\\n}\\\\nwindow.addEventListener('resize', onResize);\\\\n\\\\n// Populate the dots array with random dots\\\\ncreateDots();\\\\n\\\\n// Render the scene\\\\nwindow.requestAnimationFrame(render);\\\"\\n}\"}"
}
