{
        "title": "folder_test",
        "description": "testing my folder algo",
        "files":["b/g/boids/boids.js","b/g/boids/index.html","ascii/donut/index.html","ascii/donut/main.js","index.html"],
        "code":"{\"0\":\"{\\n        \\\"title\\\": \\\"b/g/boids/boids.js\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"files\\\":[\\\"b/g/boids/boids.js\\\",\\\"b/g/boids/index.html\\\",\\\"ascii/donut/index.html\\\",\\\"ascii/donut/main.js\\\",\\\"index.html\\\"],\\n        \\\"code\\\":\\\"// Size of canvas. These get updated to fill the whole browser.\\\\nlet width = 150;\\\\nlet height = 150;\\\\n\\\\nconst numBoids = 100;\\\\nconst visualRange = 75;\\\\n\\\\nvar boids = [];\\\\n\\\\nfunction initBoids() {\\\\n  for (var i = 0; i < numBoids; i += 1) {\\\\n    boids[boids.length] = {\\\\n      x: Math.random() * width,\\\\n      y: Math.random() * height,\\\\n      dx: Math.random() * 10 - 5,\\\\n      dy: Math.random() * 10 - 5,\\\\n      history: [],\\\\n    };\\\\n  }\\\\n}\\\\n\\\\nfunction distance(boid1, boid2) {\\\\n  return Math.sqrt(\\\\n    (boid1.x - boid2.x) * (boid1.x - boid2.x) +\\\\n      (boid1.y - boid2.y) * (boid1.y - boid2.y),\\\\n  );\\\\n}\\\\n\\\\n// TODO: This is naive and inefficient.\\\\nfunction nClosestBoids(boid, n) {\\\\n  // Make a copy\\\\n  const sorted = boids.slice();\\\\n  // Sort the copy by distance from `boid`\\\\n  sorted.sort((a, b) => distance(boid, a) - distance(boid, b));\\\\n  // Return the `n` closest\\\\n  return sorted.slice(1, n + 1);\\\\n}\\\\n\\\\n// Called initially and whenever the window resizes to update the canvas\\\\n// size and width/height variables.\\\\nfunction sizeCanvas() {\\\\n  const canvas = document.getElementById(\\\\\\\"boids\\\\\\\");\\\\n  width = window.innerWidth;\\\\n  height = window.innerHeight;\\\\n  canvas.width = width;\\\\n  canvas.height = height;\\\\n}\\\\n\\\\n// Constrain a boid to within the window. If it gets too close to an edge,\\\\n// nudge it back in and reverse its direction.\\\\nfunction keepWithinBounds(boid) {\\\\n  const margin = 200;\\\\n  const turnFactor = 1;\\\\n\\\\n  if (boid.x < margin) {\\\\n    boid.dx += turnFactor;\\\\n  }\\\\n  if (boid.x > width - margin) {\\\\n    boid.dx -= turnFactor\\\\n  }\\\\n  if (boid.y < margin) {\\\\n    boid.dy += turnFactor;\\\\n  }\\\\n  if (boid.y > height - margin) {\\\\n    boid.dy -= turnFactor;\\\\n  }\\\\n}\\\\n\\\\n// Find the center of mass of the other boids and adjust velocity slightly to\\\\n// point towards the center of mass.\\\\nfunction flyTowardsCenter(boid) {\\\\n  const centeringFactor = 0.005; // adjust velocity by this %\\\\n\\\\n  let centerX = 0;\\\\n  let centerY = 0;\\\\n  let numNeighbors = 0;\\\\n\\\\n  for (let otherBoid of boids) {\\\\n    if (distance(boid, otherBoid) < visualRange) {\\\\n      centerX += otherBoid.x;\\\\n      centerY += otherBoid.y;\\\\n      numNeighbors += 1;\\\\n    }\\\\n  }\\\\n\\\\n  if (numNeighbors) {\\\\n    centerX = centerX / numNeighbors;\\\\n    centerY = centerY / numNeighbors;\\\\n\\\\n    boid.dx += (centerX - boid.x) * centeringFactor;\\\\n    boid.dy += (centerY - boid.y) * centeringFactor;\\\\n  }\\\\n}\\\\n\\\\n// Move away from other boids that are too close to avoid colliding\\\\nfunction avoidOthers(boid) {\\\\n  const minDistance = 20; // The distance to stay away from other boids\\\\n  const avoidFactor = 0.05; // Adjust velocity by this %\\\\n  let moveX = 0;\\\\n  let moveY = 0;\\\\n  for (let otherBoid of boids) {\\\\n    if (otherBoid !== boid) {\\\\n      if (distance(boid, otherBoid) < minDistance) {\\\\n        moveX += boid.x - otherBoid.x;\\\\n        moveY += boid.y - otherBoid.y;\\\\n      }\\\\n    }\\\\n  }\\\\n\\\\n  boid.dx += moveX * avoidFactor;\\\\n  boid.dy += moveY * avoidFactor;\\\\n}\\\\n\\\\n// Find the average velocity (speed and direction) of the other boids and\\\\n// adjust velocity slightly to match.\\\\nfunction matchVelocity(boid) {\\\\n  const matchingFactor = 0.05; // Adjust by this % of average velocity\\\\n\\\\n  let avgDX = 0;\\\\n  let avgDY = 0;\\\\n  let numNeighbors = 0;\\\\n\\\\n  for (let otherBoid of boids) {\\\\n    if (distance(boid, otherBoid) < visualRange) {\\\\n      avgDX += otherBoid.dx;\\\\n      avgDY += otherBoid.dy;\\\\n      numNeighbors += 1;\\\\n    }\\\\n  }\\\\n\\\\n  if (numNeighbors) {\\\\n    avgDX = avgDX / numNeighbors;\\\\n    avgDY = avgDY / numNeighbors;\\\\n\\\\n    boid.dx += (avgDX - boid.dx) * matchingFactor;\\\\n    boid.dy += (avgDY - boid.dy) * matchingFactor;\\\\n  }\\\\n}\\\\n\\\\n// Speed will naturally vary in flocking behavior, but real animals can't go\\\\n// arbitrarily fast.\\\\nfunction limitSpeed(boid) {\\\\n  const speedLimit = 15;\\\\n\\\\n  const speed = Math.sqrt(boid.dx * boid.dx + boid.dy * boid.dy);\\\\n  if (speed > speedLimit) {\\\\n    boid.dx = (boid.dx / speed) * speedLimit;\\\\n    boid.dy = (boid.dy / speed) * speedLimit;\\\\n  }\\\\n}\\\\n\\\\nconst DRAW_TRAIL = false;\\\\n\\\\nfunction drawBoid(ctx, boid) {\\\\n  const angle = Math.atan2(boid.dy, boid.dx);\\\\n  ctx.translate(boid.x, boid.y);\\\\n  ctx.rotate(angle);\\\\n  ctx.translate(-boid.x, -boid.y);\\\\n  ctx.fillStyle = \\\\\\\"#71e2d7\\\\\\\";\\\\n  ctx.beginPath();\\\\n  ctx.moveTo(boid.x, boid.y);\\\\n  ctx.lineTo(boid.x - 15, boid.y + 5);\\\\n  ctx.lineTo(boid.x - 15, boid.y - 5);\\\\n  ctx.lineTo(boid.x, boid.y);\\\\n  ctx.fill();\\\\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\\\\n\\\\n  if (DRAW_TRAIL) {\\\\n    ctx.strokeStyle = \\\\\\\"#558cf466\\\\\\\";\\\\n    ctx.beginPath();\\\\n    ctx.moveTo(boid.history[0][0], boid.history[0][1]);\\\\n    for (const point of boid.history) {\\\\n      ctx.lineTo(point[0], point[1]);\\\\n    }\\\\n    ctx.stroke();\\\\n  }\\\\n}\\\\n\\\\n// Main animation loop\\\\nfunction animationLoop() {\\\\n  // Update each boid\\\\n  for (let boid of boids) {\\\\n    // Update the velocities according to each rule\\\\n    flyTowardsCenter(boid);\\\\n    avoidOthers(boid);\\\\n    matchVelocity(boid);\\\\n    limitSpeed(boid);\\\\n    keepWithinBounds(boid);\\\\n\\\\n    // Update the position based on the current velocity\\\\n    boid.x += boid.dx;\\\\n    boid.y += boid.dy;\\\\n    boid.history.push([boid.x, boid.y])\\\\n    boid.history = boid.history.slice(-50);\\\\n  }\\\\n\\\\n  // Clear the canvas and redraw all the boids in their current positions\\\\n  const ctx = document.getElementById(\\\\\\\"boids\\\\\\\").getContext(\\\\\\\"2d\\\\\\\");\\\\n  ctx.clearRect(0, 0, width, height);\\\\n  for (let boid of boids) {\\\\n    drawBoid(ctx, boid);\\\\n  }\\\\n\\\\n  // Schedule the next frame\\\\n  window.requestAnimationFrame(animationLoop);\\\\n}\\\\n\\\\nwindow.onload = () => {\\\\n  // Make sure the canvas always fills the whole window\\\\n  window.addEventListener(\\\\\\\"resize\\\\\\\", sizeCanvas, false);\\\\n  sizeCanvas();\\\\n\\\\n  // Randomly distribute the boids to start\\\\n  initBoids();\\\\n\\\\n  // Schedule the main animation loop\\\\n  window.requestAnimationFrame(animationLoop);\\\\n};\\\"\\n}\",\"1\":\"{\\n        \\\"title\\\": \\\"b/g/boids/index.html\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"files\\\":[\\\"b/g/boids/boids.js\\\",\\\"b/g/boids/index.html\\\",\\\"ascii/donut/index.html\\\",\\\"ascii/donut/main.js\\\",\\\"index.html\\\"],\\n        \\\"code\\\":\\\"<!DOCTYPE html>\\\\n<html>\\\\n  <head>\\\\n    <meta charset=\\\\\\\"utf-8\\\\\\\"/>\\\\n    <title>Boids</title>\\\\n    <script src=\\\\\\\"./b/g/boids/boids.js\\\\\\\"></script>\\\\n    <style type=\\\\\\\"text/css\\\\\\\">\\\\n      body {\\\\n        margin: 0;\\\\n        background: #282c34;\\\\n        overflow: hidden;\\\\n      }\\\\n    </style>\\\\n  </head>\\\\n  <body>\\\\n    <canvas id=\\\\\\\"boids\\\\\\\" width=\\\\\\\"150\\\\\\\" height=\\\\\\\"150\\\\\\\"></canvas>\\\\n  </body>\\\\n</html>\\\"\\n}\",\"2\":\"{\\n        \\\"title\\\": \\\"ascii/donut/index.html\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"files\\\":[\\\"b/g/boids/boids.js\\\",\\\"b/g/boids/index.html\\\",\\\"ascii/donut/index.html\\\",\\\"ascii/donut/main.js\\\",\\\"index.html\\\"],\\n        \\\"code\\\":\\\"<!DOCTYPE html>\\\\n<html lang=\\\\\\\"en\\\\\\\">\\\\n  <style>\\\\n  body{\\\\n  background-color:black;\\\\n  }\\\\n  </style>\\\\n<head>\\\\n    <meta charset=\\\\\\\"UTF-8\\\\\\\">\\\\n    <meta name=\\\\\\\"viewport\\\\\\\" content=\\\\\\\"width=device-width, initial-scale=1.0\\\\\\\">\\\\n    <title>Document</title>\\\\n</head>\\\\n<body>\\\\n  <script type=\\\\\\\"module\\\\\\\" src=\\\\\\\"ascii/donut/main.js\\\\\\\"></script>\\\\n</body>\\\\n</html>\\\"\\n}\",\"3\":\"{\\n        \\\"title\\\": \\\"ascii/donut/main.js\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"files\\\":[\\\"b/g/boids/boids.js\\\",\\\"b/g/boids/index.html\\\",\\\"ascii/donut/index.html\\\",\\\"ascii/donut/main.js\\\",\\\"index.html\\\"],\\n        \\\"code\\\":\\\"const donut = function() {\\\\n  const pretag = document.createElement(\\\\\\\"pre\\\\\\\");\\\\n  pretag.style = \\\\\\\"background:transparent;color:#ffddad;position:absolute;left:15%;top:15%\\\\\\\";\\\\n  document.body.appendChild(pretag);\\\\n\\\\n  let tmr1 = undefined, tmr2 = undefined;\\\\n  let A=1, B=1;\\\\n\\\\n  const asciiframe=function() {\\\\n    const b=[];\\\\n    const z=[];\\\\n    A += 0.07;\\\\n    B += 0.03;\\\\n    const cA=Math.cos(A), sA=Math.sin(A),\\\\n        cB=Math.cos(B), sB=Math.sin(B);\\\\n    for(let k=0;k<1760;k++) {\\\\n      b[k]=k%80 == 79 ? \\\\\\\"\\\\\\\\n\\\\\\\" : \\\\\\\" \\\\\\\";\\\\n      z[k]=0;\\\\n    }\\\\n    for(let j=0;j<6.28;j+=0.07) { // j <=> theta\\\\n      const ct=Math.cos(j),st=Math.sin(j);\\\\n      for(let i=0;i<6.28;i+=0.02) {   // i <=> phi\\\\n        const sp=Math.sin(i),cp=Math.cos(i),\\\\n            h=ct+2, // R1 + R2*cos(theta)\\\\n            D=1/(sp*h*sA+st*cA+5), // this is 1/z\\\\n            t=sp*h*cA-st*sA; // this is a clever factoring of some of the terms in x' and y'\\\\n\\\\n        const x=0|(40+30*D*(cp*h*cB-t*sB)),\\\\n            y=0|(12+15*D*(cp*h*sB+t*cB)),\\\\n            o=x+80*y,\\\\n            N=0|(8*((st*sA-sp*ct*cA)*cB-sp*ct*sA-st*cA-cp*ct*sB));\\\\n        if(y<22 && y>=0 && x>=0 && x<79 && D>z[o])\\\\n        {\\\\n          z[o]=D;\\\\n          b[o]=\\\\\\\".,-~:;=!*#$@\\\\\\\"[N>0?N:0];\\\\n        }\\\\n      }\\\\n    }\\\\n    pretag.innerHTML = b.join(\\\\\\\"\\\\\\\");\\\\n  };\\\\n\\\\n\\\\n\\\\nsetInterval(asciiframe, 35);\\\\n  asciiframe();\\\\n}\\\\ndonut();\\\\n\\\\n\\\"\\n}\",\"4\":\"{\\n        \\\"title\\\": \\\"index.html\\\",\\n        \\\"description\\\": \\\"\\\",\\n        \\\"files\\\":[\\\"b/g/boids/boids.js\\\",\\\"b/g/boids/index.html\\\",\\\"ascii/donut/index.html\\\",\\\"ascii/donut/main.js\\\",\\\"index.html\\\"],\\n        \\\"code\\\":\\\"<!DOCTYPE html>\\\\n<html>\\\\n  <head>\\\\n    <meta charset=\\\\\\\"utf-8\\\\\\\"/>\\\\n    <title>Boids</title>\\\\n    <script src=\\\\\\\"./b/g/boids/boids.js\\\\\\\"></script>\\\\n    <style type=\\\\\\\"text/css\\\\\\\">\\\\n      body {\\\\n        margin: 0;\\\\n        background: #282c34;\\\\n        overflow: hidden;\\\\n      }\\\\n    </style>\\\\n  </head>\\\\n  <body>\\\\n      <script type=\\\\\\\"module\\\\\\\" src=\\\\\\\"ascii/donut/main.js\\\\\\\"></script>\\\\n    <canvas id=\\\\\\\"boids\\\\\\\" width=\\\\\\\"150\\\\\\\" height=\\\\\\\"150\\\\\\\"></canvas>\\\\n  </body>\\\\n</html>\\\"\\n}\"}"
}
